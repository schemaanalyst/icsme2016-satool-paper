\section{\textit{SchemaAnalyst}}

While verifying the accuracy of the database schema is critical for protecting data integrity, manually
creating test data is expensive and time consuming. \textit{SchemaAnalyst} uses a search-based
approach in order to generate test data automatically. Figure~\ref{fig:schemaanalyst} provides a
high-level overview of the \textit{SchemaAnalyst} system.
After being given an input schema, a coverage criterion first generates a collection of test 
requirements. These test requirements are the rules that
the test data must fulfill. A test requirement for the \texttt{Inventory} schema in
Figure~\ref{fig:schema} might be, ``the \texttt{PRIMARY KEY} constraint on line three must be
violated''. A coverage criterion provides a way to systematically generate test requirements. One
example coverage criterion is Integrity Constraint Coverage (ICC). This criterion generates two test
requirements for every integrity constraint in the schema, one requiring that the constraint is
satisfied, and one requiring that the constraint is violated. \textit{SchemaAnalyst} includes nine
coverage criteria, which are explained in detail in~\cite{mcminn2015effectiveness}.

\textit{SchemaAnalyst} then generates test data
to satisfy the test requirements using a test data generator. The default test data generator used by
\textit{SchemaAnalyst} is based on Korel's Alternating Variable Method (AVM)~\cite{Korel:AVM}.
This data generator uses a fitness function to evaluate how well the test data satisfies the
requirements, and guide the test data generator towards producing higher quality test data that
satisfies more of the requirements. The \textit{SchemaAnalyst} generated the following \texttt{INSERT}
statement to violate the \texttt{PRIMARY KEY} constraint on line three in Figure~\ref{fig:schema}.

\lstinputlisting[basicstyle=\small,language=SQL]{figures/Insert.txt}

Since this data instance would set the value for the \texttt{id} field to be \texttt{NULL},
the data violates the \texttt{PRIMARY KEY} constraint, and should be rejected by the schema.
\textit{SchemaAnalyst} encodes this test case as a JUnit test case by generating Java code to execute
the \texttt{INSERT} statement on an installed DBMS, and then assert that the \texttt{INSERT} statement
was rejected by the schema. If this is the case, the test passes.  If the schema allows the bad data,
then the test case fails.

\textit{SchemaAnalyst} also includes features to evaluate the quality of the generated test data. The
coverage of the generated test data is the percentage of test requirements satisfied by the test data. 
Test data quality can also be measured using the provided mutation testing tools. When executed in
mutation testing mode, \textit{SchemaAnalyst} will generate mutant database schemas and compare the
behavior of the test data on the original and mutant schemas. \textit{SchemaAnalyst} includes 14
different mutation operators that can be used to assess test suite quality.

\input{figures/sa-new}
