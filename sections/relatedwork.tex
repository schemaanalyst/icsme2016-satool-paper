\input{figures/schemas/schemas}

\section{Related Work}\label{sec:relatedwork}

\textit{SchemaAnalyst} has been used in experimental studies, facilitating research into
search-based software testing and mutation testing.  \textit{SchemaAnalyst} has been used to enable
empirical studies appearing in five published works. 
\subsection{Survey of Results}

Kapfhammer et al. compared \textit{SchemaAnalyst} to \textit{DBMonster}
in an experiment using mutation testing over three DBMSs and 25 database 
schemas~\cite{kapfhammer2013search}. The results showed that \textit{SchemaAnalyst} outperformed
\textit{DBMonster} in terms of mutation score and constraint coverage, while remaining competitive
in execution time.

McMinn et al. organized the nine coverage criteria used in \textit{SchemaAnalyst} into an subsumption
hierarchy, and investigated the effectiveness of the criteria in a study across
three DBMSs and 32 database schemas~\cite{mcminn2015effectiveness}.  The results showed mutation
scores as low as $12\%$ for the least stringent criteria, to as high as $96\%$ for the most stringent.

Kinneer et al. conducted a study on the scalability of \textit{SchemaAnalyst}, finding that the tool
scaled well for all realistically sized schemas~\cite{kinneer2015automatically}.

Wright et al. introduced techniques for improving the efficiency of mutation testing for database
schemas using parallelisation~\cite{wright2013efficient}. These techniques were evaluated using two
DBMSs and six database schemas, with one technique resulting in one to ten times performance
improvement for both DBMSs.

McMinn et al. improved the efficiency of mutation testing for database schemas by
simulating the behavior of DBMSs, resulting in a speed increase of $51\%$ on average~\cite{mcminn2016virtual}.

Wright et al. used \textit{SchemaAnalyst} to evaluate the influence of ineffective mutants on
database schema mutation analysis in a study that used sixteen database
schemas~\cite{wright2014impact}. Removing the ineffective mutants resulted in efficiency
improvements of up to $33.7\%$.

Wright used \textit{SchemaAnalyst} to investigate mutation testing for relational database
schemas~\cite{wright2015mutation}.

\subsection{Related work}
\textit{SchemaAnalyst} uses Korel's Alternating Variable Method (AVM)~\cite{Korel:AVM},
a search technique for optimizing parameter values. AVM find the best settings using 
exploratory and pattern moves. AVM operates on one parameter at a time. The parameter is
altered in different directions in the search space during ht exploratory move phase.  Then,
whichever direction resulted in the most improvement in fitness is taken until the fitness stops 
improving. AVM repeats this process for each parameter under consideration until the fitness is
high enough, or until the search budget is exhausted.

Fraser and Arcuri presented \textit{EvoSuite}, a tool for test data generation for
Java programs~\cite{Fraser2011evosuite}.
Like \textit{SchemaAnalyst}, \textit{EvoSuite} uses a search-based approach 
to generate test data. However, \textit{EvoSuite} generates test data for Java programs, while
\textit{SchemaAnalyst} focuses on generating test data for relational database schemas.

More information on software testing, including coverage criteria and logic testing
can be found in Ammann and Offutt's book~\cite{ammann2008}.

Silberschatz et al. provide a resource with more information on relational databases,
database schemas, and integrity constraints~\cite{databasebook}.

McMinn provides on overview of search-based software testing~\cite{STVR:STVR294}.

Kinneer enhanced \textit{SchemaAnalyst} to generate test data for relational database
queries, providing evidence of \textit{SchemaAnalyst}'s extensibility~\cite{kinneer2016comp}.
